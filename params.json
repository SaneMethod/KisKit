{"name":"Kiskit","tagline":"Straightforward PHP framework particularly suited for REST APIs.","body":"KisKit\r\n======\r\n(Keep It Simple Kit)\r\n\r\nKisKit is a featureful but straightforward PHP web framework. Particularly suited to use with modern, REST-oriented\r\nclient-side frameworks, but flexible enough to be used however you see fit.\r\n\r\nKiskit offers MVC style project organization, a simple database abstraction layer, quality logging (PSR-3 compliant)\r\nand compatibility/extensibility (framework is PSR-4 compliant, and includes easy setup and use of\r\n[composer](http://getcomposer.org)), making adding libraries like monolog, SwiftMailer or Doctrine\r\n(or hundreds of others) a simple and familiar process.\r\n\r\nSee [Composer](http://getcomposer.org) and [Packagist](https://packagist.org) for more details on using composer as\r\na php package manager, and [PHP-FIG](http://php-fig.org) for details on PSRs.\r\n\r\n\r\n###Contents\r\n\r\n#####[Setup](#kiskit-setup)\r\n* [One-Time Setup Steps](#one-time-setup-steps)\r\n* [Recurring Setup Steps](#recurring-setup-steps)\r\n\r\n#####[Configuration Details](#configuring-kiskit)\r\n* [Constants](#constants)\r\n* [Config Files](#config-files)\r\n\r\n#####[Routing](#routing-1)\r\n* [Parameters](#routing-parameters)\r\n* [Requests](#requests)\r\n* [RESTful](#restful)\r\n\r\n#####[Controllers](#controllers-1)\r\n* [Views](#view)\r\n* [JSON](#json)\r\n* [File](#file)\r\n* [Upload](#upload)\r\n* [Model](#model)\r\n* [Helper](#helper)\r\n* [Lib](#lib)\r\n* [Load](#load)\r\n\r\n#####[Databases, PDO and Models](#databases-pdo-and-models-1)\r\n* [Using Models](#using-models)\r\n* [Model Properties](#model-properties)\r\n* [Model Functions](#model-functions)\r\n* [Model CreateTable](#model-createtable)\r\n\r\n#####[Exceptions and Logging](#exceptions-and-logging-1)\r\n* [Configuration](#configuration)\r\n* [Logging Exceptions](#exceptions)\r\n* [Logging Object](#logging-object)\r\n\r\nKisKit Setup\r\n============\r\n\r\nKisKit is a straightforward PHP framework. The following are the necessary step to get it up and\r\nrunning.\r\n\r\nFor setup beyond the immediate scope of KisKit (such as Apache/nginx setup, SQL server setup, etc.), please see\r\nthe specific documentation for the software in question.\r\n\r\nOne-Time Setup Steps\r\n--------------------\r\n\r\n1. Alter `config.php`, `logconfig.php` and `dbconfig.php` to reflect your configuration - all can be found in the\r\n`config` directory.\r\n    * See sections [Constants](#constants) and [Config Files](#config-files) below to get more details on what each of\r\n    these configuration files contain and do.\r\n    * KisKit offers a simple abstraction layer for database interaction that sit atop PHP's\r\n[PDO](http://www.php.net/manual/en/intro.pdo.php) database interface, and is thus compatible with any db solution\r\n[supported by PDO](http://www.php.net/manual/en/pdo.drivers.php).\r\n        * For the impatient, this includes MSSQL/SQL Azure, MySQL, SQLite and PostgreSQL.\r\n\r\n2. Alter `composer.json` in the root directory to indicate your package requirements. This file follows\r\nthe format of a [composer.json file](http://getcomposer.org/doc/04-schema.md). A sample composer.json file\r\nis included in the package and can function as a customizable base.\r\n\r\n3. Define the `createTable` functions in any models you know you need at this point - these will be run in\r\nstep 4, using the database configuration details from step 1. You can skip this if you don't want to automatically\r\ncreate your tables when running setup.\r\n\r\n4. In a terminal, change directory to the system/cli directory for your project (default is `system/cli`) and run\r\n `php -f setup.php`. If you wish to see the command line options for setup, type `php -f setup.php -- --help`.\r\n You may need to determine where php is installed for your system if its not on the PATH (ie. env/bin/php).\r\n This will check your php install and setup against requirements, download and install Composer,\r\n install the required packages defined in composer.json, and init any model tables you may have defined.\r\n You can rerun this setup at any time in order to install any packages you've added to requires.json, and to\r\n initialize tables for any models you've added.\r\n     * Note also that once you've run setup once, composer will be available in your APP_DIR/vendor/composer\r\n     directory - you can run it via `php composer.phar`, which will give you a list of available commands.\r\n\r\nKisKit is now prepared for use.\r\n\r\nRecurring Setup Steps\r\n---------------------\r\n\r\n1. Whenever you want to add a new package to the project, you'll want to make the appropriate changes to your\r\n`composer.json` file, and then either run `php -f setup.php` again, or run `php composer.phar` directly.\r\n2. If you create new models and want to use the createTable functions to generate the tables for you, simply\r\nrun `php -f setup.php` again. Having the models contain the statements for table setup can hasten later setup\r\non a remote server, and offers insight into the table structure for developers.\r\n\r\nConfiguring Kiskit\r\n==================\r\n\r\nConstants\r\n---------\r\nIn addition to any you define in `config.php`, the following constants will be present and available to all\r\ncontrollers and views:\r\n\r\n**SERVER_ROOT**: The base directory from which KisKit is executing. This is the same as the directory in which\r\nthe root index.php file can be found. For example, `F:/usr/etc/apache2/htdocs/mysitedir/`. Gauranteed to use\r\nforward slashes (even on Windows), and to have a trailing slash.\r\n\r\n**BASE_URL**: The base url for the request. For example, `http://mysite.com/`. The protocol will be set appropriately\r\n(either http or https), and a trailing slash is guaranteed. This will include `/index.php/` if index.php is not being\r\nrewritten out of the url (as is the default via the included .htaccess file).\r\n\r\n**APP_DIR**: The base directory for your application (as opposed to the system files). This is 'app/'\r\nby default - notice the trailing slash, which should be included if you change this value.\r\nYour app directory must conform to the directory structure of the default app dir (you can add as many\r\ndirectories as you want, but at least controllers, models and views must exist.)\r\n\r\n**SYS_DIR**: The directory where the KisKit system files will live, that your application relies on/extends from.\r\nThis is 'system/' by default.\r\n\r\n**DEFAULT_CONTROLLER**: When navigating to the root of your site, the named controller will be the one to handle\r\nthe request, calling its `index()` function. Default is 'home'.\r\n\r\n**DB_GROUP**: This indicates which database group from `dbconfig.php` should be used to interact with the db.\r\nCan be left blank if you're not going to use a database, or intend to interact with it via some method other than\r\nPDO and KisKit models. Default value is 'development'.\r\n\r\n**EXCEPT_HANDLER**: Indicates which log settings group from `logconfig.php` should be used to handle logging and\r\nexceptions. Can be left blank (empty string, null, etc.) if you're going to handle logging/exceptions via some other\r\nmethod. Default value is 'development'.\r\n\r\nConfig Files\r\n------------\r\n\r\n**config.php**: This file contains certain constants that define application directories and options, as noted in\r\nthe `CONSTANTS` section.\r\n\r\n**dbconfig.php**: This file contains a multidimensional array, each element of which is an array of database\r\nconfiguration options. Each array should be named according to the value you will set `DB_GROUP` to in `config.php`.\r\n\r\nSee [Databases, PDO and Models](#databases-pdo-and-models-1) for more details.\r\n\r\nExample:\r\n\r\n```php\r\n'development' => array(\r\n    'hostname' => '127.0.0.1',\r\n    'driver' => 'mysql',\r\n    // Number to specify port, null to use default port\r\n    'port' => 3306,\r\n    'username' => 'dbuser',\r\n    'password' => 'dbpass',\r\n    'database' => 'dbname'\r\n)\r\n```\r\n\r\n**logconfig.php**: Similar in structure to the dbconfig.php file, containing a multidimensional array, each element\r\nis an array of logging configuration options. Each array should be named according to the value you will set\r\n`EXCEPTION_HANDLER` to in `config.php`.\r\n\r\nSee [Exceptions and Logging](#exceptions-and-logging-1) for more details.\r\n\r\nExample:\r\n\r\n```php\r\n'development' => array(\r\n    'logPath' => SERVER_ROOT . APP_DIR . 'logs/',\r\n    'logTemplate' => 'error',\r\n    'webTrace' => true,\r\n    'stderr' => false,\r\n    'file' => 100,\r\n    'html' => 100,\r\n    'json' => false\r\n)\r\n```\r\n\r\nRouting\r\n=======\r\nThe initial point of entry from a request will always be index.php at the root. Within index, the autoloader will\r\nbe loaded (to handle PSR-0 and PSR-4 conforming libs/packages), logging will be instantiated (if using\r\nEXCEPT_HANDLER), and routing will begin.\r\n\r\nThe first section of the uri after the base is always the controller, and the second is always a public\r\nfunction within that controller.\r\n\r\nFor example:\r\n`http://mysite.com/home/dothis/`\r\n\r\nWill instantiate the HomeController class in home.php within the app/controllers directory.\r\nIt will then check whether there's a method named 'dothis' in home, and whether dothis is public. If both are\r\ntrue, dothis will handle the request. If the former is false, an exception (with code 404) is thrown. If the\r\nlatter, an exception (with code 403) is thrown. ExceptHandler will understand these as HTTP exceptions and\r\ntreat them accordingly, sending the proper headers and a customizable error page (see\r\n[Logging](#exceptions-and-logging-1) for more details).\r\n\r\n### Routing Parameters\r\nParameters can be passed into a function via either the uri or the query string when performing any request.\r\n\r\nFor example, if we have a function defined as:\r\n```php\r\npublic function dothis(param1, param2)\r\n```\r\nAnd we make the call\r\n`http://mysite.com/home/dothis/cheese/pizza`\r\n\r\nThen param1 in dothis will be set to 'cheese', and param2 will be set to 'pizza'.\r\n\r\nWe can also specify by name in any order if we use the query string.\r\n\r\n`http://mysite.com/home/dothis?param2=pizza&param1=cheese`\r\n\r\nWill still result in param1 being 'cheese' and param2 being 'pizza' inside of the function.\r\n\r\nWe can also mix and match uri params and query string params, and named params in the query string will still\r\nget assigned to their proper variable.\r\n\r\n`http://mysite.com/home/dothis/pizza?param1=cheese`\r\n\r\nWill still result in param1 being assigned 'cheese' and our leftover parameter will be assigned to param2, thus\r\n'pizza'. If more parameters exist in the uri then are defined on the controller, all named parameters are assigned\r\nfirst, and then any leftover parameters are assigned in order to the remainder. In order to access all parameters,\r\nyou can directly access the parameter array via `$this->request->params` in any controller function.\r\n\r\nYou can set defaults on any function parameter; if there are less parameters set via the uri and/or query string\r\nthan exist on the controller, the default values for the leftover parameters will prevail.\r\n\r\nYou can also directly access the $_GET or $_POST arrays from `$this->request->get` and `$this->request->post`\r\nrespectively. These are merely convenience references that point directly to the $_GET and $_POST arrays - any\r\nchanges to them will also change the $_GET and $_POST arrays. Changes to the params array will not effect either\r\nthe $_GET or $_POST, or $this->request->get/post.\r\n\r\nOn POST requests, you will need to access `$this->request->post` or $_POST in order to get variables passed via\r\nPOST. Parameters passed via the uri will still be set appropriately.\r\n\r\n###Requests\r\n\r\nFor each request, a new Request object is created. The request object contains the request method (ie. GET, POST,\r\netc.), the target controller name, target function name, a merge array of parameters passed via uri sections and\r\nvia GET query string, and references to $_GET and $_POST.\r\n\r\nThe request object is always available to the called controller function via `$this->request`.\r\n\r\nThe request object has the following accessible properties:\r\n* `verb` => The request method (GET, POST, PUT, OPTIONS, DELETE)\r\n* `target` => The target controller file name, minus any extension.\r\n* `controller` => The target controller class name. Note that controllers in KisKit have a postfix of 'Controller' -\r\nso, if you have a home.php containing your home controller, the class name should be `HomeController`. You can\r\nchange or remove this prefix by setting 'conPostFix'=>false in the array passed to Router in `index.php`.\r\n* `method` => The function being called with the target controller.\r\n* `params` => The merged array of params from the query string and uri, set in the order that the named params exist\r\non the function called, if any.\r\n* `get` => A direct reference to $_GET.\r\n* `post` => A direct reference to $_POST.\r\n\r\n###RESTful\r\n\r\nAs a convenience to those making a RESTful API, you can specify in the function name what request method it should\r\nhandle, instead of needing to have a messy if statement on the value of `$this->request->verb` in your function.\r\n\r\nFor example, if you want to declare a function, 'dothis', that handles only GET requests, and another that handles\r\nonly POST requests, and a final version that handles all others, you would declare:\r\n```php\r\npublic function dothis_GET(param1, param2){}\r\npublic function dothis_POST(param1, param2, param3){}\r\npublic function dothis(){}\r\n```\r\n\r\nWhen `http://mysite.com/home/dothis/` is called via GET, the router will call dothis_GET first, if found. If not\r\nfound, it will call the un-postfixed function. Thus, you can specify handlers for specific request methods, and\r\na default handler for all others, with the name and the postfix clearly representing their relationship and the\r\nconditions under which they'll be called.\r\n\r\nControllers\r\n===========\r\n\r\nAll controllers must live in your APP_DIR/controllers directory. Each controller should be named according to the\r\nclass you intend. The naming rule is:\r\n\r\nFile name: name.php\r\nController Class name: NameController\r\n\r\nNote the Controller postfix. You can change or eliminate this postfix, as noted under [Requests](#requests)\r\nshould you so desire.\r\n\r\nAll controllers should extend the Controller class from system\\core.\r\n\r\n```php\r\nuse sanemethod\\kiskit\\system\\core\\Controller;\r\n\r\nclass NameController extends Controller {}\r\n```\r\n\r\nThere is no need to explictly include the Controller php file - it will be automatically included for you.\r\n\r\nAll public fuctions within a controller are accessible via url navigation; all protected and private functions are\r\nnot, and any attempt to call them from url navigation will result in a 403.\r\n\r\nAll Controller functions will have access to `$this->request` (a [Request](#requests) object), and, if\r\nEXCEPT_HANDLER is set, `$this->logger` (an [ExceptHandler](#logging-object) object).\r\n\r\n###Functions\r\nAll Controllers have the following functions:\r\n\r\n####View\r\n`$this->view()` => Display a php view. These views can be composited.\r\nFor Example:\r\n\r\n```php\r\n$this->view('header');\r\n$this->view('content');\r\n$this->view('footer');\r\n```\r\n\r\nWill display a single page comprised of the resulting markup of these three views.\r\n\r\nThe first argument to view must be the view file. By default, all controllers will look in the APP_DIR/views\r\ndirectory for a file named the same as the string specified, minus the extension (ie. `header.php`). You can split\r\nthe views into their own subdirectories and either specify the subdirectory when calling the view (ie.\r\n`$this->view('home/header.php')`) or set a constant VIEW_LOC on the controller which indicates where all the views\r\nfor this controller should be found (ie. `const VIEW_LOC = 'home';`).\r\n\r\nThe second argument is optional - an array of values that will be extracted as local variables.\r\n\r\n```php\r\n$this->view('content', ['firstvar'=>'banana', 'secondvar'=>'pie']);\r\n```\r\n\r\nInside the view file, you will now have access to $firstvar and $secondvar.\r\n\r\n####Json\r\n`$this->json()` => Return json to the client. This sends the appropriate headers (and thus must not be called if\r\nany other output has previously occurred), and outputs the results of [json_encode](http://ca1.php.net/json_encode).\r\nThe first argument should be the value (array, object, etc.) to encode, and the optional second argument encoding\r\noptions as per the PHP json_encode function.\r\n\r\nExample:\r\n\r\n```php\r\n$this->json(['first'=>1, 'second'=>2, 'third'=>3]);\r\n```\r\n\r\nReturns:\r\n\r\n```json\r\n{\"first\":1, \"second\":2, \"third\":3}\r\n```\r\n\r\n####File\r\n`$this->file()` => Offers a file for download, as specified by the arguments to the function call.\r\n\r\nExample:\r\n\r\n```php\r\n$this->file('path/To/File.txt', 'newFileName.txt');\r\n```\r\n\r\n####Upload\r\n`$this->upload()` => Handle a (potentially chunked) file upload. Returns JSON representation of file details and\r\nwrite success. If chunked upload, also returns the content range written.\r\n\r\nExample:\r\n\r\n```php\r\n$this->upload('newFileName.txt', 'path/to/save/to', 'json');\r\n```\r\n\r\nReturns:\r\n\r\n```json\r\n{\"file\":{\"size\":123560, \"name\":\"newFileName.txt\", \"path\":\"path/to/save/to\", type:\"mimeType\"}, \"success\":true}\r\n```\r\n\r\n####Model\r\n`$this->model()` => Load the specified model. Returns a new [model object](#using-models).\r\n\r\nExample:\r\n\r\n```php\r\n$users = $this->model('users');\r\n$firstUser = $users->selectOne(['where'=>['user_id' => 1]]);\r\n```\r\n\r\n####Helper\r\n`$this->helper()` => Load a helper - a class that provide some particular functionality (like email or file\r\nhandling). Returns a new object of that class. As helpers can be a varied lot, see the individual helper to\r\ndetermine its usage.\r\n\r\nExample:\r\n\r\n```php\r\n$email = $this->helper('email');\r\n$email->from('test@test.com')->to([\"first@test.com\", \"second@test.com\"])\r\n            ->subject('Test Email')->message(\"Message String\")->send();\r\n```\r\n\r\n####Lib\r\n`$this->lib()` => Load a third-party library (installed under the vendor directory, PSR-0 or PSR-4 compliant or,\r\nwith the proper configuration in the Composer autoload, otherwise). Returns a new object of the specified class.\r\nWhat this object will offer you is entirely library specific. Note that you **DON'T** have to use this to\r\nload third-party libraries - its merely a convenience (indeed, helpers and models can also be loaded via\r\ndirect reference - just add the appropriate `use` statement above the Controller class).\r\n\r\nExample:\r\n\r\n```php\r\n$monologJsonFormatter = $this->lib('Monolog\\Formatter\\JsonFormatter', arg1, arg2);\r\n```\r\n\r\nIs just an alias for:\r\n\r\n```php\r\n$monologJsonFormatter = new Monolog\\Formatter\\JsonFormatter(arg1, arg2);\r\n```\r\n\r\n####Load\r\n`$this->load()` => Load an arbitrary file, and instantiate a class found therein. This method underlies the\r\nother class loading methods, and allows you to specify certain options if you want to avoid using the defaults\r\n(for instance, you want to load a model whose class doesn't have the 'Model' postfix).\r\n\r\nExample:\r\n\r\n```php\r\n$this->load(SERVER_ROOT.APP_DIR.'models/users');\r\n```\r\n\r\nWill load `users.php` from the specified directory and attempt to instantiate and return an object of class `Users`.\r\n\r\nDatabases, PDO and Models\r\n=========================\r\nAll of your models must live in the APP_DIR/models directory by default, and should extend system/core/Model.\r\n\r\nExample:\r\n\r\n```php\r\nuse sanemethod\\kiskit\\system\\core\\Model;\r\n\r\nclass UserModel extends Model{}\r\n```\r\n\r\nNote the 'Model' postfix - all model classes should end in Model (in the same way that all Controller classes\r\nshould end in Controller) by default. You can use [Load](#load) to instantiate your model class and\r\navoid this, if you prefer.\r\n\r\n####Using Models\r\nKisKit models provide a layer of abstraction over PHP PDO, which itself is a data-access abstraction layer for\r\nvarious databases. It is not meant to be comprehensive - in some cases, you will want to create functions\r\non each model to directly interact with PDO, rather than using simple abstractions. In many cases, however,\r\nthe abstractions may save time on simple, routine operations.\r\n\r\nAll Models should have a `__construct` function that calls construct on the super class and establishes the\r\ndatabase connection.\r\n\r\n```php\r\nfunction __construct()\r\n{\r\n    parent::__construct();\r\n    $this->dbh = $this->dbConnect();\r\n}\r\n```\r\n\r\nThis database handle (dbh) should then be used when manually preparing PDO SQL statements. See\r\n[PDO](http://www.php.net/manual/en/intro.pdo.php) for more details.\r\n\r\n#####Model properties\r\nEvery model possess the following properties:\r\n\r\n`table` => The name of the table, as a string. Empty string by default. You should set this within the class.\r\n\r\nExample:\r\n\r\n```php\r\nclass UserModel extends Model{\r\n    protected $table = 'table_name';\r\n```\r\n\r\n`fieldWhiteList` => An array of strings, indicating names of fields in the table that insertion and\r\nupdate operations are allowed on. Any fields included in a insert or update operation that aren't in the\r\nwhite list will be silently filtered out.\r\n\r\n#####Model functions\r\nEvery model possesses the following db abstractions for selecting, inserting, updating and deleting rows.\r\n\r\n`$this->tableExists()` => Check whether $this->table exists in the database. Returns boolean.\r\n`$this->select()` => Select any number of rows from this table based on the $where array, where each key should be\r\nthe field we want to select on in the db, and the array value the value of said field: array(id=>5, name=>'bob').\r\nSelect all fields (default) or specify fields as an array (id, name, date) or as a string \"id, name, date\".\r\nReturns an associative (potentially multi-dimensional) array if successful, false otherwise.\r\n\r\n    @param array $options{\r\n        @type string|array $fields\r\n        @type array $where\r\n        @type int $fetchMode\r\n        @type bool $fetchOne Whether to limit this fetch to a single result.\r\n    }\r\n    @return bool|array\r\n\r\nExample:\r\n\r\n```php\r\nvar $users = $this->model('users');\r\n$user->select(['fields'=>'name', 'where'=>['user_songs' => 1]]);\r\n```\r\n\r\nWill return an array of the name field of all user rows that match the criteria.\r\n\r\n`$this->selectOne()` => As select, but will fetch only the first row of any result set.\r\n`$this->insert()` => Inserts a single record into the table. Accepts an associative array as a parameter,\r\nwhere each key should correspond to a table field name, with the associated value being inserted into that column.\r\nIt is never required to include a tables primary key unless it doesn't possess a default value.\r\n\r\nExample:\r\n\r\n```php\r\n$this->insert(['name'=>'Bob', 'songs'=>5]);\r\n```\r\n\r\n`$this->insertMany()` => As insert, passing instead a multidimensional array, where element of the array is\r\nan array formatted as per insert. Transactional.\r\n\r\n`$this->update` => Update a single row based on the $record and $where arrays. The $where array should contain\r\nkey(s) that exist within our $record array, and indicate which $keys should be used for the WHERE statement.\r\nParameters: array $record, array|string $where.\r\n\r\nExample:\r\n\r\n```php\r\n$this->update(['name'=>'joe'], ['id'=>5]);\r\n```\r\n\r\n`$this->updateMany()` => As per update, with the same modifications as insertMany.\r\n\r\n`$this->delete()` => Delete any number of rows which match the where statement.\r\nParameter: array|string $where\r\n\r\nExample:\r\n\r\n```php\r\n$this->delete(['id'=>5]);\r\n```\r\n\r\n#####Model CreateTable\r\nDefinining a function named `createTable()` on a model will cause that function to be run during the execution\r\nof `setup.php`. This is an excellent way to have tables automatically generated for you when running - the code\r\nwithin will only execute if the table doesn't currently exist.\r\n\r\nExample:\r\n\r\n```php\r\n/**\r\n * Create the table.\r\n * @return bool false if failed to create table, else true\r\n */\r\nfunction createTable()\r\n{\r\n    $ct = $this->dbh->prepare(\r\n        \"CREATE TABLE {$this->table} (\r\n          user_id INT NOT NULL,\r\n          user_code VARCHAR(255) NOT NULL,\r\n          PRIMARY KEY (user_id)\r\n        )\"\r\n    );\r\n    $ct->execute();\r\n}\r\n```\r\n\r\nExceptions and Logging\r\n======================\r\n\r\n####Configuration\r\nError Levels:\r\n\r\n* 100 => 'DEBUG'\r\n* 200 => 'INFO'\r\n* 250 => 'NOTICE'\r\n* 300 => 'WARNING'\r\n* 600 => 'ERROR'\r\n* 700 => 'CRITICAL'\r\n* 800 => 'ALERT'\r\n* 900 => 'EMERGENCY'\r\n\r\nSetting any of the possible error outputs to one of the error levels will cause all errors of that level and\r\nabove to be logged to the appropriate output.\r\n\r\nPossible Error Outputs:\r\n\r\n* 'stderr' => php standard error output (php://stderr) - usually for CLI;\r\n* 'file' => log to a file (date-stamped, stored in logPath);\r\n* 'html' => log as html output (using logTemplate, detail controlled by webTrace);\r\n* 'json' => log as json output (will override html).\r\n\r\nWebtrace:\r\n\r\n* true == display full details of errors in html error page, including stack trace.\r\n* false == display only simple error messages.\r\n\r\n####Exceptions\r\nSo long as `EXCEPT_HANDLER` is set, all exceptions will be picked up on (but not caught) by ExceptHandler\r\n(accessible from Controllers as $this->logger). This allows us to log exceptions, fatal or otherwise, to\r\nfiles and other appropriate outputs. By default, ExceptHandler will output to a file named according to\r\nthe date (ie. 2014_01_31.log).\r\n\r\nDepending on the value of `webTrace`, the html output will include either the full strack trace in addition\r\nto a meaingful error message, or just a simple error message.\r\n\r\nAny uncaught exceptions you throw can also trigger logging and display, so you can, for instance, throw an\r\nexception with a 403 from isnide of a controller to trigger display of a 403 message.\r\n\r\nExample:\r\n\r\n```php\r\nthrow new Exception('Access Denied', 403);\r\n```\r\n\r\n####Logging Object\r\nYou can also without throwing exceptions from any controller, via `$this->logger`. For any log, you can specify the\r\nlog level, log message, and an optional array which will be interpolated with the log message.\r\n\r\nExample:\r\n\r\n```php\r\n$this->logger->log(ExceptHandler::ALERT, \"Replace {this} and {like} it!\", [\"this\"=>\"that\", \"like\"=>\"hate\"]);\r\n```\r\n\r\nWill result in a log message like: `Replace that and hate it!`\r\n\r\nYou can also use level specific aliases to skip needing to specify the log level.\r\n\r\nExample:\r\n\r\n```php\r\n$this->logger->debug('Simple Debug Message');\r\n$this->logger->info('Info message - slightly higher level than debug!');\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}